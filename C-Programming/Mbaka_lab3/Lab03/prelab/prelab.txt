Message #2 was sent to stderr
Message #5 was sent to stderr
Message #1 was sent to stdout
Message #3 was sent to stdout
Message #4 was sent to stdout
I am 4196608 years old.
I am 4195808 inches tall.

The string contains 'This string is way to long and will corrupt memory'

The order of messages in `prelab.txt` differs from the on-screen output due to stdout's block buffering when redirected to a file, causing delayed flushing until the buffer is full or the program ends. Stderr, however, is unbuffered, leading to immediate flushing. This results in a different message sequence in the file, especially if the program crashes before stdout is fully flushed. Core dumps, generated by the OS during a crash, are not captured in standard streams and thus not in `prelab.txt`, requiring tools like gdb or direct examination of the core file for analysis.




==176125== Memcheck, a memory error detector
==176125== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==176125== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==176125== Command: ./lab_a
==176125== 
Message #2 was sent to stderr
Message #5 was sent to stderr
==176125== Conditional jump or move depends on uninitialised value(s)
==176125==    at 0x4E81C5E: vfprintf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E8A4E8: printf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x400788: main (lab_a.c:21)
==176125==  Uninitialised value was created by a stack allocation
==176125==    at 0x4006CD: main (lab_a.c:8)
==176125== 
==176125== Use of uninitialised value of size 8
==176125==    at 0x4E7F32B: _itoa_word (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E835B0: vfprintf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E8A4E8: printf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x400788: main (lab_a.c:21)
==176125==  Uninitialised value was created by a stack allocation
==176125==    at 0x4006CD: main (lab_a.c:8)
==176125== 
==176125== Conditional jump or move depends on uninitialised value(s)
==176125==    at 0x4E7F335: _itoa_word (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E835B0: vfprintf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E8A4E8: printf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x400788: main (lab_a.c:21)
==176125==  Uninitialised value was created by a stack allocation
==176125==    at 0x4006CD: main (lab_a.c:8)
==176125== 
==176125== Conditional jump or move depends on uninitialised value(s)
==176125==    at 0x4E835FF: vfprintf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E8A4E8: printf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x400788: main (lab_a.c:21)
==176125==  Uninitialised value was created by a stack allocation
==176125==    at 0x4006CD: main (lab_a.c:8)
==176125== 
==176125== Conditional jump or move depends on uninitialised value(s)
==176125==    at 0x4E81D2B: vfprintf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E8A4E8: printf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x400788: main (lab_a.c:21)
==176125==  Uninitialised value was created by a stack allocation
==176125==    at 0x4006CD: main (lab_a.c:8)
==176125== 
==176125== Conditional jump or move depends on uninitialised value(s)
==176125==    at 0x4E81DAE: vfprintf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x4E8A4E8: printf (in /usr/lib64/libc-2.17.so)
==176125==    by 0x400788: main (lab_a.c:21)
==176125==  Uninitialised value was created by a stack allocation
==176125==    at 0x4006CD: main (lab_a.c:8)
==176125== 
==176125== Invalid write of size 8
==176125==    at 0x4007DC: main (lab_a.c:31)
==176125==  Address 0x5205048 is 8 bytes inside a block of size 12 alloc'd
==176125==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==176125==    by 0x400797: main (lab_a.c:25)
==176125== 
==176125== Invalid write of size 8
==176125==    at 0x4007EA: main (lab_a.c:31)
==176125==  Address 0x5205050 is 4 bytes after a block of size 12 alloc'd
==176125==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==176125==    by 0x400797: main (lab_a.c:25)
==176125== 
==176125== Invalid write of size 8
==176125==    at 0x4007F8: main (lab_a.c:31)
==176125==  Address 0x5205058 is 12 bytes after a block of size 12 alloc'd
==176125==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==176125==    by 0x400797: main (lab_a.c:25)
==176125== 
==176125== Invalid write of size 8
==176125==    at 0x400806: main (lab_a.c:31)
==176125==  Address 0x5205060 is 20 bytes after a block of size 12 alloc'd
==176125==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==176125==    by 0x400797: main (lab_a.c:25)
==176125== 
==176125== Invalid write of size 8
==176125==    at 0x400814: main (lab_a.c:31)
==176125==  Address 0x5205068 is 24 bytes after a block of size 16 in arena "client"
==176125== 

valgrind: m_mallocfree.c:307 (get_bszB_as_is): Assertion 'bszB_lo == bszB_hi' failed.
valgrind: Heap block lo/hi size mismatch: lo = 80, hi = 8029185230041804917.
This is probably caused by your program erroneously writing past the
end of a heap block and corrupting heap metadata.  If you fix any
invalid writes reported by Memcheck, this assertion failure will
probably go away.  Please try that before reporting this as a bug.


host stacktrace:
==176125==    at 0x5804C3A3: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x5804C4B7: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x5804C651: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x58055BD3: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x58043813: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x58042796: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x58047462: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x58041D0B: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x58019521: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==176125==    by 0x1008C7E2B6: ???
==176125==    by 0x1008BA9F2F: ???
==176125==    by 0x1C0F: ???
==176125==    by 0x100200852F: ???
==176125==    by 0x400797: main (lab_a.c:25)

sched status:
  running_tid=1

Thread 1: status = VgTs_Runnable (lwpid 176125)
==176125==    at 0x400818: main (lab_a.c:31)
client stack range: [0x1FFEFFC000 0x1FFF000FFF] client SP: 0x1FFEFFF370
valgrind stack range: [0x1008AAA000 0x1008BA9FFF] top usage: 7200 of 1048576


Note: see also the FAQ in the source distribution.
It contains workarounds to several common problems.
In particular, if Valgrind aborted or crashed after
identifying problems in your program, there's a good chance
that fixing those problems will prevent Valgrind aborting or
crashing, especially if it happened in m_mallocfree.c.

If that doesn't help, please report this bug to: www.valgrind.org

In the bug report, send all the above text, the valgrind
version, and what OS and version you are using.  Thanks.

Message #2 was sent to stderr
Message #5 was sent to stderr
Message #1 was sent to stdout
Message #3 was sent to stdout
Message #4 was sent to stdout
I am 4196608 years old.
I am 6 inches tall.

The string contains 'This string is way to long and will corrupt memory'
==177464== Memcheck, a memory error detector
==177464== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==177464== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==177464== Command: ./lab_a
==177464== 
Message #2 was sent to stderr
Message #5 was sent to stderr
==177464== Invalid write of size 8
==177464==    at 0x4007E3: main (lab_a.c:31)
==177464==  Address 0x5205048 is 8 bytes inside a block of size 12 alloc'd
==177464==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==177464==    by 0x40079E: main (lab_a.c:25)
==177464== 
==177464== Invalid write of size 8
==177464==    at 0x4007F1: main (lab_a.c:31)
==177464==  Address 0x5205050 is 4 bytes after a block of size 12 alloc'd
==177464==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==177464==    by 0x40079E: main (lab_a.c:25)
==177464== 
==177464== Invalid write of size 8
==177464==    at 0x4007FF: main (lab_a.c:31)
==177464==  Address 0x5205058 is 12 bytes after a block of size 12 alloc'd
==177464==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==177464==    by 0x40079E: main (lab_a.c:25)
==177464== 
==177464== Invalid write of size 8
==177464==    at 0x40080D: main (lab_a.c:31)
==177464==  Address 0x5205060 is 20 bytes after a block of size 12 alloc'd
==177464==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==177464==    by 0x40079E: main (lab_a.c:25)
==177464== 
==177464== Invalid write of size 8
==177464==    at 0x40081B: main (lab_a.c:31)
==177464==  Address 0x5205068 is 24 bytes after a block of size 16 in arena "client"
==177464== 

valgrind: m_mallocfree.c:307 (get_bszB_as_is): Assertion 'bszB_lo == bszB_hi' failed.
valgrind: Heap block lo/hi size mismatch: lo = 80, hi = 8029185230041804917.
This is probably caused by your program erroneously writing past the
end of a heap block and corrupting heap metadata.  If you fix any
invalid writes reported by Memcheck, this assertion failure will
probably go away.  Please try that before reporting this as a bug.


host stacktrace:
==177464==    at 0x5804C3A3: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x5804C4B7: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x5804C651: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x58055BD3: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x58043813: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x58042796: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x58047462: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x58041D0B: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x58019521: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==177464==    by 0x1008C7E2EE: ???
==177464==    by 0x1008BA9F2F: ???
==177464==    by 0x1C0F: ???
==177464==    by 0x100200852F: ???
==177464==    by 0x40079E: main (lab_a.c:25)

sched status:
  running_tid=1

Thread 1: status = VgTs_Runnable (lwpid 177464)
==177464==    at 0x40081F: main (lab_a.c:31)
client stack range: [0x1FFEFFC000 0x1FFF000FFF] client SP: 0x1FFEFFF370
valgrind stack range: [0x1008AAA000 0x1008BA9FFF] top usage: 7200 of 1048576


Note: see also the FAQ in the source distribution.
It contains workarounds to several common problems.
In particular, if Valgrind aborted or crashed after
identifying problems in your program, there's a good chance
that fixing those problems will prevent Valgrind aborting or
crashing, especially if it happened in m_mallocfree.c.

If that doesn't help, please report this bug to: www.valgrind.org

In the bug report, send all the above text, the valgrind
version, and what OS and version you are using.  Thanks.

Message #2 was sent to stderr
Message #5 was sent to stderr
Message #1 was sent to stdout
Message #3 was sent to stdout
Message #4 was sent to stdout
I am 22 years old.
I am 6 inches tall.

The string contains 'This string is way to long and will corrupt memory'
==179584== Memcheck, a memory error detector
==179584== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==179584== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==179584== Command: ./lab_a
==179584== 
Message #2 was sent to stderr
Message #5 was sent to stderr
==179584== Invalid write of size 8
==179584==    at 0x4007E8: main (lab_a.c:31)
==179584==  Address 0x5205048 is 8 bytes inside a block of size 12 alloc'd
==179584==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==179584==    by 0x4007A3: main (lab_a.c:25)
==179584== 
==179584== Invalid write of size 8
==179584==    at 0x4007F6: main (lab_a.c:31)
==179584==  Address 0x5205050 is 4 bytes after a block of size 12 alloc'd
==179584==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==179584==    by 0x4007A3: main (lab_a.c:25)
==179584== 
==179584== Invalid write of size 8
==179584==    at 0x400804: main (lab_a.c:31)
==179584==  Address 0x5205058 is 12 bytes after a block of size 12 alloc'd
==179584==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==179584==    by 0x4007A3: main (lab_a.c:25)
==179584== 
==179584== Invalid write of size 8
==179584==    at 0x400812: main (lab_a.c:31)
==179584==  Address 0x5205060 is 20 bytes after a block of size 12 alloc'd
==179584==    at 0x4C2C089: calloc (vg_replace_malloc.c:762)
==179584==    by 0x4007A3: main (lab_a.c:25)
==179584== 
==179584== Invalid write of size 8
==179584==    at 0x400820: main (lab_a.c:31)
==179584==  Address 0x5205068 is 24 bytes after a block of size 16 in arena "client"
==179584== 

valgrind: m_mallocfree.c:307 (get_bszB_as_is): Assertion 'bszB_lo == bszB_hi' failed.
valgrind: Heap block lo/hi size mismatch: lo = 80, hi = 8029185230041804917.
This is probably caused by your program erroneously writing past the
end of a heap block and corrupting heap metadata.  If you fix any
invalid writes reported by Memcheck, this assertion failure will
probably go away.  Please try that before reporting this as a bug.


host stacktrace:
==179584==    at 0x5804C3A3: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x5804C4B7: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x5804C651: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x58055BD3: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x58043813: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x58042796: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x58047462: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x58041D0B: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x58019521: ??? (in /usr/libexec/valgrind/memcheck-amd64-linux)
==179584==    by 0x1008C7E356: ???
==179584==    by 0x1008BA9F2F: ???
==179584==    by 0x1C0F: ???
==179584==    by 0x100200852F: ???
==179584==    by 0x4007A3: main (lab_a.c:25)

sched status:
  running_tid=1

Thread 1: status = VgTs_Runnable (lwpid 179584)
==179584==    at 0x400824: main (lab_a.c:31)
client stack range: [0x1FFEFFC000 0x1FFF000FFF] client SP: 0x1FFEFFF370
valgrind stack range: [0x1008AAA000 0x1008BA9FFF] top usage: 7200 of 1048576


Note: see also the FAQ in the source distribution.
It contains workarounds to several common problems.
In particular, if Valgrind aborted or crashed after
identifying problems in your program, there's a good chance
that fixing those problems will prevent Valgrind aborting or
crashing, especially if it happened in m_mallocfree.c.

If that doesn't help, please report this bug to: www.valgrind.org

In the bug report, send all the above text, the valgrind
version, and what OS and version you are using.  Thanks.

==183114== Memcheck, a memory error detector
==183114== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==183114== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==183114== Command: ./lab_a
==183114== 






Message #2 was sent to stderr
Message #5 was sent to stderr
Message #1 was sent to stdout
Message #3 was sent to stdout
Message #4 was sent to stdout
I am 22 years old.
I am 6 inches tall.

The string contains 'This string is way to long and will corrupt memory'
==193183== Memcheck, a memory error detector
==193183== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==193183== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==193183== Command: ./lab_a
==193183== 
Message #2 was sent to stderr
Message #5 was sent to stderr
Message #1 was sent to stdout
Message #3 was sent to stdout
Message #4 was sent to stdout
I am 22 years old.
I am 6 inches tall.

The string contains 'This string is way to long and will corrupt memory'
==193183== 
==193183== HEAP SUMMARY:
==193183==     in use at exit: 0 bytes in 0 blocks
==193183==   total heap usage: 1 allocs, 1 frees, 51 bytes allocated
==193183== 
==193183== All heap blocks were freed -- no leaks are possible
==193183== 
==193183== For lists of detected and suppressed errors, rerun with: -s
==193183== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
