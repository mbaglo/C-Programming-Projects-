-------------- hw6c_1  x1, no move fopen
Elapsed CPU Time DataTimer = 6.66 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 1.665000e-02 seconds
Elapsed CPU Time CalcTimer = 0.25 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 6.250000e-06 seconds
move fopen to top disabled 
2000000 data lines processed, the least square line is : Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 6.61 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 1.652500e-02 seconds
Elapsed CPU Time CalcTimer = 0.24 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 6.000000e-06 seconds
move fopen to top disabled 
2000000 data lines processed, the least square line is : Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 6.62 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 1.655000e-02 seconds
Elapsed CPU Time CalcTimer = 0.24 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 6.000000e-06 seconds
move fopen to top disabled 
2000000 data lines processed, the least square line is : Y = 1.26393 * X + 
0.823035

-------------- hw6c_2  x2, no move fopen
Elapsed CPU Time DataTimer = 13.67 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 1.708750e-02 seconds
Elapsed CPU Time CalcTimer = 0.49 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 6.125000e-06 seconds
move fopen to top disabled 
4000000 data lines processed, the least square line is : Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 13.69 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 1.711250e-02 seconds
Elapsed CPU Time CalcTimer = 0.48 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 6.000000e-06 seconds
move fopen to top disabled 
4000000 data lines processed, the least square line is : Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 13.70 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 1.712500e-02 seconds
Elapsed CPU Time CalcTimer = 0.48 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 6.000000e-06 seconds
move fopen to top disabled 
4000000 data lines processed, the least square line is : Y = 1.26393 * X + 
0.823035

-------------- hw6c_f1 x1, yes move fopen
Elapsed CPU Time DataTimer = 0.01 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 2.500000e-05 seconds
Elapsed CPU Time CalcTimer = 0.00 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 0.000000e+00 seconds
move fopen to top enabled 
5000 data lines processed, the least square line is : Y = -nan * X + -nan

Elapsed CPU Time DataTimer = 0.01 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 2.500000e-05 seconds
Elapsed CPU Time CalcTimer = 0.00 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 0.000000e+00 seconds
move fopen to top enabled 
5000 data lines processed, the least square line is : Y = -nan * X + -nan

Elapsed CPU Time DataTimer = 0.01 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 2.500000e-05 seconds
Elapsed CPU Time CalcTimer = 0.00 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 0.000000e+00 seconds
move fopen to top enabled 
5000 data lines processed, the least square line is : Y = -nan * X + -nan

-------------- hw6c_f2 x2, yes move fopen
Elapsed CPU Time DataTimer = 0.01 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 1.250000e-05 seconds
Elapsed CPU Time CalcTimer = 0.00 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 0.000000e+00 seconds
move fopen to top enabled 
5000 data lines processed, the least square line is : Y = -nan * X + -nan

Elapsed CPU Time DataTimer = 0.01 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 1.250000e-05 seconds
Elapsed CPU Time CalcTimer = 0.00 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 0.000000e+00 seconds
move fopen to top enabled 
5000 data lines processed, the least square line is : Y = -nan * X + -nan

Elapsed CPU Time DataTimer = 0.01 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 1.250000e-05 seconds
Elapsed CPU Time CalcTimer = 0.00 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 0.000000e+00 seconds
move fopen to top enabled 
5000 data lines processed, the least square line is : Y = -nan * X + -nan

-------------- hw6cpp_1 x1
Elapsed CPU Time DataTimer = 1.34 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 3.350000e-03 seconds
Elapsed CPU Time CalcTimer = 2.85 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 7.125000e-05 seconds
2000400 data lines processed, the best least squares line is: Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 1.35 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 3.375000e-03 seconds
Elapsed CPU Time CalcTimer = 2.86 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 7.150000e-05 seconds
2000400 data lines processed, the best least squares line is: Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 1.35 seconds
Elapsed CPU Time per Iteration (DataTimer, 400) = 3.375000e-03 seconds
Elapsed CPU Time CalcTimer = 2.85 seconds
Elapsed CPU Time per Iteration (CalcTimer, 40000) = 7.125000e-05 seconds
2000400 data lines processed, the best least squares line is: Y = 1.26393 * X + 
0.823035

-------------- hw6cpp_2 x2
Elapsed CPU Time DataTimer = 2.68 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 3.350000e-03 seconds
Elapsed CPU Time CalcTimer = 5.62 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 7.025000e-05 seconds
4000800 data lines processed, the best least squares line is: Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 2.67 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 3.337500e-03 seconds
Elapsed CPU Time CalcTimer = 5.65 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 7.062500e-05 seconds
4000800 data lines processed, the best least squares line is: Y = 1.26393 * X + 
0.823035

Elapsed CPU Time DataTimer = 2.67 seconds
Elapsed CPU Time per Iteration (DataTimer, 800) = 3.337500e-03 seconds
Elapsed CPU Time CalcTimer = 5.64 seconds
Elapsed CPU Time per Iteration (CalcTimer, 80000) = 7.050000e-05 seconds
4000800 data lines processed, the best least squares line is: Y = 1.26393 * X + 
0.823035

--------------------------------------------------
Average of the Elapsed CPU Time for Each Test Case
---------------------------------------------------

-------------- hw6c_1  x1, no move fopen

Elapsed CPU Time DataTimer:
  - Average = (6.66 + 6.61 + 6.62) / 3 = 6.63 seconds

Elapsed CPU Time per Iteration (DataTimer, 400):
  - Average = (1.665e-02 + 1.6525e-02 + 1.655e-02) / 3 = 1.6575e-02 seconds

Elapsed CPU Time CalcTimer:
  - Average = (0.25 + 0.24 + 0.24) / 3 = 0.2433 seconds

Elapsed CPU Time per Iteration (CalcTimer, 40000):
  - Average = (6.25e-06 + 6e-06 + 6e-06) / 3 = 6.0833e-06 seconds

 -------------- hw6c_2  x2, no move fopen

Elapsed CPU Time DataTimer:
  - Average = (13.67 + 13.69 + 13.70) / 3 = 13.6867 seconds

Elapsed CPU Time per Iteration (DataTimer, 800):
  - Average = (1.70875e-02 + 1.71125e-02 + 1.7125e-02) / 3 = 1.710833e-02 
seconds

Elapsed CPU Time CalcTimer:
  - Average = (0.49 + 0.48 + 0.48) / 3 = 0.4867 seconds

Elapsed CPU Time per Iteration (CalcTimer, 80000):
  - Average = (6.125e-06 + 6e-06 + 6e-06) / 3 = 6.041667e-06 seconds

-------------- hw6c_f1 x1, yes move fopen

Elapsed CPU Time DataTimer:
  - Average = (0.01 + 0.01 + 0.01) / 3 = 0.01 seconds

Elapsed CPU Time per Iteration (DataTimer, 400):
  - Average = (2.5e-05 + 2.5e-05 + 2.5e-05) / 3 = 2.5e-05 seconds

Elapsed CPU Time CalcTimer:
  - All values are 0.00 seconds, so the average is 0.00 seconds.

Elapsed CPU Time per Iteration (CalcTimer, 40000):
  - All values are 0.000000e+00 seconds, so the average is 0.00 seconds.

-------------- hw6c_f2 x2, yes move fopen

Elapsed CPU Time DataTimer:
  - Average = (0.01 + 0.01 + 0.01) / 3 = 0.01 seconds

- Elapsed CPU Time per Iteration (DataTimer, 800):
  - Average = (1.25e-05 + 1.25e-05 + 1.25e-05) / 3 = 1.25e-05 seconds

- Elapsed CPU Time CalcTimer:
  - All values are 0.00 seconds, so the average is 0.00 seconds.

- Elapsed CPU Time per Iteration (CalcTimer, 80000):
  - All values are 0.000000e+00 seconds, so the average is 0.00 seconds.

-------------- hw6cpp_1 x1

Elapsed CPU Time DataTimer:
  - Average = (1.34 + 1.35 + 1.35) / 3 = 1.3467 seconds

Elapsed CPU Time per Iteration (DataTimer, 400):
  - Average = (3.35e-03 + 3.375e-03 + 3.375e-03) / 3 = 3.366667e-03 seconds

Elapsed CPU Time CalcTimer:
  - Average = (2.85 + 2.86 + 2.85) / 3 = 2.8533 seconds

Elapsed CPU Time per Iteration (CalcTimer, 40000):
  - Average = (7.125e-05 + 7.15e-05 + 7.125e-05) / 3 = 7.133333e-05

-------------- hw6cpp_2 x2

Elapsed CPU Time DataTimer:
  - Average = (2.68 + 2.67 + 2.67) / 3 = 2.6733 seconds

Elapsed CPU Time per Iteration (DataTimer, 800):
  - Average = (3.35e-03 + 3.3375e-03 + 3.3375e-03) / 3 = 3.341667e-03 seconds

Elapsed CPU Time CalcTimer:
  - Average = (5.62 + 5.65 + 5.64) / 3 = 5.6367 seconds

Elapsed CPU Time per Iteration (CalcTimer, 80000):
  - Average = (7.025e-05 + 7.0625e-05 + 7.05e-05) / 3 = 7.045833e-05 seconds

--------------------------------------------------------------------------
Q1. Comparison of hw6c_1 (x1, no move fopen) and hw6c_2 (x2, no move fopen)
--------------------------------------------------------------------------
Elapsed CPU Time DataTimer:

hw6c_1: 6.63 seconds
hw6c_2: 13.6867 seconds

When the loop count is doubled in hw6c_2, the total CPU time for reading data 
roughly doubles, which indicates a linear relationship between the number of 
iterations and the total CPU time for data reading.

Elapsed CPU Time per Iteration (DataTimer):

hw6c_1: 1.6575e-02 seconds
hw6c_2: 1.710833e-02 seconds

The per-loop CPU time for reading data slightly increases when the loop count 
is doubled. This slight increase could be due to additional overhead as the 
number of iterations increases or other factors affecting I/O performance.

Elapsed CPU Time CalcTimer:

hw6c_1: 0.2433 seconds
hw6c_2: 0.4867 seconds
Similar to the DataTimer, the total CPU time for calculations roughly doubles 
with the doubled loop count, indicating a linear relationship between the loop 
count and the total calculation time.

Elapsed CPU Time per Iteration (CalcTimer):

hw6c_1: 6.0833e-06 seconds
hw6c_2: 6.041667e-06 seconds

The per-loop CPU time for calculations slightly decreases when the loop count 
is doubled. This decrease could be due to more efficient use of CPU cache or 
other optimizations that become more effective with a larger number of 
calculations.


---------------------------------------------------------------------------
Q2. Comparison of hw6c_f1 (x1, yes move fopen) and hw6c_f2 (x2, yes move fopen)
---------------------------------------------------------------------------
a. Elapsed CPU Time DataTimer:

hw6c_f1: 0.01 seconds
hw6c_f2: 0.01 seconds

The total CPU time for data reading remains constant at 0.01 seconds despite 
doubling the loop count. This consistency likely results from the file being 
opened just once at the start, minimizing the impact of I/O operations on total 
elapsed time.

b. Elapsed CPU Time per Iteration (DataTimer):

hw6c_f1: 2.5e-05 seconds
hw6c_f2: 1.25e-05 seconds

Interestingly, the per-loop CPU time for data reading decreases by half when 
the loop count is doubled. This improvement suggests that the overhead of file 
handling becomes less significant per iteration as the total number of 
iterations increases.

c. Elapsed CPU Time CalcTimer and Per Iteration (CalcTimer):

Both hw6c_f1 and hw6c_f2 report 0.00 seconds for total and per-iteration 
calculation times, indicating that the calculations either did not execute or 
executed too quickly to be measured accurately under the current timing 
resolution.

d. Validity of Results:

The appearance of -nan values for the calculated least square line coefficients 
(Y = -nan * X + -nan) in both hw6c_f1 and hw6c_f2 suggests that there might be 
a logical or runtime error in how the calculations are performed or in the data 
being processed when MOVE_FOPEN is enabled. These -nan results indicate invalid 
or undefined numerical operations, likely due to less repetition time.

e. Given these invalid results, the performance metrics associated with the 
calculation times (showing 0.00 seconds) are also questionable, as they might 
not reflect actual computational work. Measuring the performance of code that 
doesn't work is essentially futile 
because the primary goal is to assess how efficiently the code accomplishes its 
intended tasks. If the code fails to produce the correct outcomes, any data on 
its speed or resource usage is irrelevant since it's not successfully 
completing its required functions. The focus should first be on ensuring the 
code works correctly before considering its performance.

---------------------------------------------------------
Q2. Comparison of hw6c_1 (C code) and hw6cpp_1 (C++ code)
---------------------------------------------------------
a.  Elapsed CPU Time DataTimer (I/O Performance):

hw6c_1: 6.63 seconds (C)
hw6cpp_1: 1.3467 seconds (C++)

The C++ implementation demonstrates significantly faster I/O operations 
compared to the C implementation. This could be due to various factors, such as 
differences in the efficiency of I/O libraries used, buffering strategies, or 
the way file operations are handled in each language.

b.  Elapsed CPU Time CalcTimer (Calculation Performance):

hw6c_1: 0.2433 seconds (C)
hw6cpp_1: 2.8533 seconds (C++)

In contrast to I/O performance, the C implementation outperforms the C++ 
implementation in terms of calculation speed. This discrepancy could result 
from differences in how the two languages or their standard libraries implement 
mathematical operations, manage memory, or optimize code execution.


---------------------------------------------
Comparison of hw6cpp_1 (x1) and hw6cpp_2 (x2)
---------------------------------------------

a.  Elapsed CPU Time DataTimer (I/O Performance):

hw6cpp_1: 1.3467 seconds
hw6cpp_2: 2.6733 seconds

The total CPU time for data I/O operations in hw6cpp_2 is approximately double 
that of hw6cpp_1, which indicates a linear relationship between the number of 
iterations and the total CPU time for data reading, as expected with doubled 
loop count.

b.  Elapsed CPU Time per Iteration (DataTimer):

hw6cpp_1: 3.366667e-03 seconds
hw6cpp_2: 3.341667e-03 seconds

Despite the doubling of the loop count, the per-loop CPU time for data reading 
remains nearly constant, with a slight decrease in hw6cpp_2. This slight 
decrease might suggest that any fixed overhead associated with I/O operations 
is more effectively amortized over the larger number of iterations.

c. Elapsed CPU Time CalcTimer (Calculation Performance):

hw6cpp_1: 2.8533 seconds
hw6cpp_2: 5.6367 seconds

Similar to the I/O performance, the total CPU time for calculations roughly 
doubles from hw6cpp_1 to hw6cpp_2, aligning with the increase in loop count and 
suggesting a linear relationship between workload size and computation time.

d. Elapsed CPU Time per Iteration (CalcTimer):

hw6cpp_1: 7.133333e-05 seconds
hw6cpp_2: 7.045833e-05 seconds

The per-loop CPU time for calculations shows a slight decrease when the loop 
count is doubled, indicating that the code might be slightly more efficient on 
a per-iteration basis with a larger number of calculations. This could be due 
to better utilization of CPU resources, such as caching, when performing a 
larger batch of computations.